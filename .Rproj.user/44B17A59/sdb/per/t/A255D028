{
    "contents" : "globalVariables(\"q.colors\")\n#' Distance between points\n#' \\code{Distance} A Euclidean distance between points\n#'\n#' @param e1x The x coordinate of a point.\n#' @param e1y The y coordinate of a point.\n#' @param e2x The x coordinate of another point.\n#' @param e2y The y coordinate of another point.\n#' @return The distance.\nDistance <- function(e1x, e1y, e2x, e2y) {\n  #\n  sqrt(SquaredDistance(e1x, e1y, e2x, e2y))\n}\n\n#' Squared distance between points\n#' \\code{SquaredDistance} Squared Euclidean distance between points\n#'\n#' @param e1x The x coordinate of a point.\n#' @param e1y The y coordinate of a point.\n#' @param e2x The x coordinate of another point.\n#' @param e2y The y coordinate of another point.\n#' @return The squared distance.\nSquaredDistance <- function(e1x, e1y, e2x, e2y) {\n  (e2y - e1y)^2 + (e2x - e1x)^2\n}\n\n#' Distance to a line segment\n#' \\code{DistanceToLineSegment} Computes the distance between a point and the nearest point on a line segment\n#'\n#' @param px The x coordinate of a point.\n#' @param py The y coordinate of a point.\n#' @param ax The x coordinate of one end of a line.\n#' @param ay The y coordinate of one end of a line.\n#' @param bx The x coordinate of the other end of a line.\n#' @param by The y coordinate of the other end of a line.\n#' @return The distance.\nDistanceToLineSegment <- function(px, py, ax, ay, bx, by) {\n  l2 <- SquaredDistance(ax, ay, bx, by)\n  if (l2 == 0)\n    return(sqrt(SquaredDistance(px, py, ax, ay)))\n  t <- ((px - ax) * (bx - ax) + (py - ay) * (by - ay)) / l2\n  if (t < 0)\n    return(sqrt(SquaredDistance(px, py, ax, ay)))\n  if (t > 1)\n    return(sqrt(SquaredDistance(px, py, bx, by)))\n  sqrt(SquaredDistance(px, py, ax + t * (bx - ax), ay + t * (by - ay)))\n}\n\n#' Distance to a line segment\n#' \\code{DistanceToBox} Computes the distance between a point and the nearest point on a box (0 if in the box)\n#'\n#' @param px The x coordinate of a point.\n#' @param py The y coordinate of a point.\n#' @param ax The x coordinate of the bottom-left of the box.\n#' @param ay The y coordinate of the bottom-left of the box.\n#' @param bx The x coordinate of the bottom-right of the box.\n#' @param by The y coordinate of the bottom-right of the box.\n#' @param cx The x coordinate of the top-right of the box.\n#' @param cy The y coordinate of the top-right of the box.\n#' @param dx The xcoordinates of the top-left of the box.\n#' @param dy The y coordinate of the top-left of the box.\n#' @return The squared distance.\nDistanceToBox <- function(px, py, ax, ay, bx, by, cx, cy, dx, dy) {\n  d.horizontal <- Distance(ax, ay, bx, by)\n  d.vertical <- Distance(bx, by, cx, cy)\n  d.p.ab <- DistanceToLineSegment(px, py, ax, ay, bx, by)\n  d.p.bc <- DistanceToLineSegment(px, py, bx, by, cx, cy)\n  d.p.cd <- DistanceToLineSegment(px, py, cx, cy, dx, dy)\n  d.p.da <- DistanceToLineSegment(px, py, dx, dy, ax, ay)\n  print(c(d.horizontal, d.vertical,d.p.ab, d.p.bc, d.p.cd, d.p.da ))\n  # checking to see if point is in the box\n  if (d.p.bc <= d.horizontal & d.p.da <= d.horizontal & d.p.ab <= d.vertical & d.p.cd <= d.vertical)\n    return(0)\n  min(d.p.ab, d.p.bc, d.p.cd, d.p.da)\n}\n\n#' Whether or not two boxes overlap\n#' \\code{BoxOverlap} Checks to see if two boxes overlap\n#'\n#' @param ax1 The x coordinate of the bottom-left of the first box.\n#' @param ay1 The y coordinate of the bottom-left of the first box.\n#' @param bx1 The x coordinate of the bottom-right of the first box.\n#' @param by1 The y coordinate of the bottom-right of the first box.\n#' @param cx1 The x coordinate of the top-right of the first box.\n#' @param cy1 The y coordinate of the top-right of the first box.\n#' @param dx1 The x coordinate of the top-left of the first box.\n#' @param dy1 The y coordinate of the top-left of the first box.\n#' @param ax2 The x coordinate of the bottom-left of the second box.\n#' @param ay2 The y coordinate of the bottom-left of the second box.\n#' @param bx2 The x coordinate of the bottom-right of the second box.\n#' @param by2 The y coordinate of the bottom-right of the second box.\n#' @param cx2 The x coordinate of the top-right of the second box.\n#' @param cy2 The y coordinate of the top-right of the second box.\n#' @param dx2 The x coordinate of the top-left of the second box.\n#' @param dy2 The y coordinate of the top-left of the second box.\n#' @return true if the boxes overlap and false otherwise.\nBoxOverlap <- function(ax1, ay1, bx1, by1, cx1, cy1, dx1, dy1, ax2, ay2, bx2, by2, cx2, cy2, dx2, dy2) {\n  # Returns: boolean\n  #\npublic boolean overlaps (Rectangle r) {\n    return x < r.x + r.width && x + width > r.x && y < r.y + r.height && y + height > r.y;\n}\n#   if (DistanceToBox(ax1, ay1, ax2, ay2, bx2, by2, cx2, cy2, dx2, dy2) == 0)\n#     return(TRUE)\n#   if (DistanceToBox(bx1, by1, ax2, ay2, bx2, by2, cx2, cy2, dx2, dy2) == 0)\n#     return(TRUE)\n#   if (DistanceToBox(cx1, cy1, ax2, ay2, bx2, by2, cx2, cy2, dx2, dy2) == 0)\n#     return(TRUE)\n#   if (DistanceToBox(dx1, dy1, ax2, ay2, bx2, by2, cx2, cy2, dx2, dy2) == 0)\n#     return(TRUE)\n#   if (DistanceToBox(ax2, ay2, ax1, ay1, bx1, by1, cx1, cy1, dx1, dy1) == 0)\n#     return(TRUE)\n#   if (DistanceToBox(bx2, by2, ax1, ay1, bx1, by1, cx1, cy1, dx1, dy1) == 0)\n#     return(TRUE)\n#   if (DistanceToBox(cx2, cy2, ax1, ay1, bx1, by1, cx1, cy1, dx1, dy1) == 0)\n#     return(TRUE)\n#   if (DistanceToBox(dx2, dy2, ax1, ay1, bx1, by1, cx1, cy1, dx1, dy1) == 0)\n#     return(TRUE)\n#   FALSE\n}\n\n\n#' Box coordinates\n#' \\code{BoxOverlap} Computes the positions of the corner of a box.\n#'\n#' @param x x coordinate of the middle of the box.\n#' @param y y coordinate of the middle of the box.\n#' @param w width of the box in the x-scale.\n#' @param h height  of the box in the y-scale.\n#' @return A vector containing the coordinates of a box.\nBoxCoordinates = function(x, y, w, h) {\n  p1 <- x - w / 2\n  p2 <- y - h / 2\n  p3 = x + w / 2\n  p4 = y + h / 2\n  c(p1, p2, p3, p2, p3, p4, p1, p4)\n}\n\n#' Box center\n#' \\code{BoxCenter} Computes the coordinates of the center of a box based upon the coordinates of the corner.\n#'\n#' @param ax The x coordinate of the bottom-left of the box.\n#' @param ay The y coordinate of the bottom-left of the box.\n#' @param bx The x coordinate of the bottom-right of the box.\n#' @param by The y coordinate of the bottom-right of the box.\n#' @param cx The x coordinate of the top-right of the box.\n#' @param cy The y coordinate of the top-right of the box.\n#' @param dx The x coordinate of the top-left of the box.\n#' @param dy The y coordinate of the top-left of the box.\n#' @return vector containing the x,y coordinates of the center.\nBoxCenter = function(ax, ay, bx, by, cx, cy, dx, dy) {\n  c((ax + bx) / 2, (ay + dy) / 2)\n}\n\n#' Box Overlaps\n#' \\code{OverlapIndex} Returns the index of the first overlapping box encountered.\n#'\n#' @param boxes A list of boxes, where each box is its coordinates.\n#' @param this.box The box to check to see if it overlaps with the rest.\n#' @param this.box.index The index of this.box in the list of boxes.\n#' @return -1 if no overlaps found..\n#' @export\nOverlapIndex <- function(boxes, this.box, this.box.index) {\n    if (length(boxes) == 0)\n        return(-1)\n    for (i in 1:length(boxes))\n        if (i != this.box.index)\n        {\n            box <- boxes[[i]]\n            if (BoxOverlap(box[1],box[2],box[3],box[4],box[5],box[6],box[7],box[8], this.box[1],this.box[2],this.box[3],this.box[4],this.box[5],this.box[6],this.box[7],this.box[8]))\n                return(i)\n        }\n  -1\n}\n\n#' ggplot xlim\n#' \\code{GetXlim}\n#'\n#' @param p A \\code{\\link[ggplot2]{ggplot}} plot.\n#' @return A vector containing the minimum and and maximum value of x plotted.\nGetXlim = function(p) {\n  g = ggplot2::ggplot_build(p)\n  g$panel$ranges[[1]]$x.range\n}\n\n#' ggplot ylim\n#' \\code{GetYlim}\n#'\n#' @param p A \\code{\\link[ggplot2]{ggplot}} plot.\n#' @return A vector containing the minimum and and maximum value of y  plotted.\nGetYlim <- function(p) {\n  g <- ggplot2::ggplot_build(p)\n  g$panel$ranges[[1]]$y.range\n}\n\n#' Find better cootrdinates for text labels\n#' \\code{GetYlim} Identifies a better set of coordinates to place labels in a labeled ggplot scatterplot.\n#'\n#' @param p A \\code{\\link[ggplot2]{ggplot}} plot.\n#' @param do.nothing If TRUE, the algorithm does nothing, other than return values.\n#' @param fixed.aspect If TRUE, forces the x and y dimensions to be on the same scale.\n#' @param tstep The angle (theta) step size as the algorithm spirals out.\n#' @param rstep The radius step size (in standard deviations) as the algorithm spirals out.\n#' @param rstep The radius step size (in standard deviations) as the algorithm spirals out.\n#' @param overlap.fudge Determines the amount of space required between labels. A value of 1 corresponds to a best guess of\n#' no overlap. The guess can be wrong, so the plot can be improved by modifying this value, which has a muliplier effect.\n#' @return dimensions Width and height of the text to be plotted in terms of the scale of x and y.\nReducePointAndLabelOverlap <- function (p, label.size, do.nothing = FALSE, fixed.aspect = FALSE, tstep = 0.1, rstep = 0.1, overlap.fudge = 1){\n    # Inspired by  wordlayout {wordcloud}\n    #\n    # getting the coordinates\n    labels <- p$data$labels\n    label.coords <- point.coords <- p$data[,1:2]\n    col.labels <- colnames(label.coords)\n    n <- length(labels)\n    # determining scale of the points and text relative to plot coordinates (dodgy hack)\n    #print( par()$pin)\n    #  print( p$data)\n    #  print(p$panel$ranges[[1]])\n    #  plot(p)\n    #  stop(\"dog\")\n    #xlim <-\n    rng.x <- diff(GetXlim(p)) * 1.1 #Adjustment to deal with space left outside of convex hull of points.\n     print(\"rng.x\")\n     print(rng.x)\n    rng.y <- diff(GetYlim(p)) * 1.1\n     print(\"rng.y\")\n     print(rng.y)\n    width.plotting.region <- par()$pin[1] * 25.4 * .8 # Hack due to inaccuracy of pin\n     print(\"width.plotting.region\")\n     print(width.plotting.region)\n    height.plotting.region <- par()$pin[2] * 25.4 * .96\n     print(\"height.plotting.region\")\n     print(height.plotting.region)\n\n\n    x.p.mm <- rng.x / width.plotting.region\n    y.p.mm <- rng.y / height.plotting.region\n     print(\"x.p.mm\")\n     print(x.p.mm)\n     print(\"y.p.mm\")\n     print(y.p.mm)\n     print(fixed.aspect)\n     if (fixed.aspect)\n        x.p.mm <- y.p.mm <- max(x.p.mm, y.p.mm)\n     print(\"x.p.mm\")\n     print(x.p.mm)\n     print(\"y.p.mm\")\n     print(y.p.mm)\n\n    inches.to.mm.fudge  <- label.size * 1.384615 * 1.8 / 1.95 / overlap.fudge\n    character.height.mm <-  strheight(\"Jj\", \"inches\") * inches.to.mm.fudge\n    #line.height.y.scale <- character.height.mm * y.p.mm * 1.02 # Adjustment for gaps between lines\n    smallish.size <- character.height.mm * x.p.mm\n    widths <- strwidth(labels, \"inches\") * inches.to.mm.fudge * x.p.mm# / initial.x.scale\n    n.lines <- 1 + stringr::str_count(labels, \"\\n\")\n    heights <- strheight(labels, \"inches\") * inches.to.mm.fudge * y.p.mm\n    dimensions <- matrix(c(widths,heights), n, 2, dimnames = list(labels, c(\"width\", \"height\")))\n    print(dimensions)\n    sdx <- sd(label.coords[,1], na.rm = TRUE)\n    sdy <- sd(label.coords[,2], na.rm = TRUE)\n    if (sdx == 0)\n    sdx <- 1\n    if (sdy == 0)\n    sdy <- 1\n    # computing position of the points.\n    # preventing overlap of points\n#     for (i in 2:n)\n#         for (prev.i in 1:(i - 1))\n#             if (sum(point.coords[i,] == point.coords[prev.i,]) == 2)\n#             {\n#                 w <- widths[i]\n#                 h <- heights[i]\n#                 radian <- 2 * pi * (n + i) / (2 * n)\n#                 point.coords[i, 1] <- point.coords[i, 1] + w / 4 * cos(radian)\n#                 point.coords[i, 2] <- point.coords[i, 2] + h / 4 * sin(radian)\n#             }\n    # getting the coordinates for the labels, with the initial labels positioned\n    # above the points if they are single lines of text, and in the \"middle\" otherwise, trying\n    # to prevent the point being within a letter.\n    offset <- rep(0, n)\n#    offset[n.lines %% 2 == 1] <- 0.5\n    offset[n.lines  == 1] <- 1\n    offset[n.lines  == 2] <- 0.1\n    offset[n.lines  == 3] <- 0.23\n    label.coords[, 2] <- point.coords[, 2] + heights * offset\n    # Computing the coordinates of the boxes at their initial positions (after being moved off the point)\n    boxes <- vector(\"list\", n)\n    for (i in 1:n)\n        boxes[[i]] <- BoxCoordinates(label.coords[i,1], label.coords[i,2],\n          widths[i], heights[i])\n    names(boxes) <- labels\n    print(boxes)\n#\n    # Moving labels outwards in a spiral until they no longer overlap.\n    #\n    box.coordinates <- vector(\"list\", n)\n    thetas <- 2 * pi * (1:n) / n\n    if (!do.nothing)\n    {\n        for (i in 1:n)\n        {\n            theta <- thetas[i]\n            x1 <- label.coords[i, 1]\n            y1 <- label.coords[i, 2]\n            x0 <- point.coords[i, 1]\n            y0 <- point.coords[i, 2]\n            r <- 0\n            label <- labels[i]\n            w <- widths[i]\n            h <- heights[i]\n            overlapped <- TRUE\n            new.position.counter <- 0\n            while (overlapped)\n            {\n                this.box <- BoxCoordinates(x1, y1, w, h)\n                print(paste(\"this.box\", i))\n\n                #print(boxes[[i]])\n                #stop(\"dog\")\n                overlaps.with <-OverlapIndex(boxes, this.box, i)\n                if (overlaps.with == -1)\n                {\n                    boxes[[i]] <- this.box\n                    label.coords[i, ] <-  c(x1, y1)\n                    overlapped <- FALSE\n                    print(\"no overlap\")\n                    print(this.box)\n                }\n                else\n                {\n                    #\n                    print(paste(\"Moving\", i, \" due to overlap with \", overlaps.with))\n                    # Trying to position the label on a different side of the point.\n                    new.position.counter <- new.position.counter + 1\n                    if (new.position.counter == 1)\n                    {   # Trying to put the label lower down\n                        y1 <- y0 - h * offset[i]\n                    }\n                    else if (new.position.counter == 2)\n                    {    # trying to put the point to the left\n                         x1 <- x0 - w / 2## - (smallish.size + widths[i])\n                         y1 <- y0# - h * 1.2\n                    }\n                    else if (new.position.counter == 3)\n                    {# trying to put the point to the right\n                         x1 <- x0 + w / 2## - (smallish.size + widths[i])\n                         y1 <- y0# - h * 1.2\n                    }\n                    else\n                    {\n                        theta <- theta + tstep\n                        r <- r + rstep * tstep / (2 * pi)\n                        x1 <- x0 + sdx * r * cos(theta)\n                        y1 <- y0 + sdy * r * sin(theta)\n                    }\n                }\n            }\n        }\n    }\n    print(boxes)\n    list(label.coords = as.data.frame(label.coords), dimensions = dimensions)\n}\n\n\n#' Find better cootrdinates for text labels\n#' \\code{LabeledScatterPlot} Scatterplot with Labeled Points.\n#' @param coords The xy coordinates of the points.\n#' @param group A factor indicating group membership for each point.\n#' @param row.labels A vector of labels which will, if supplied, over-ride the rownames of coodinates.\n#' @param col.labels A vector of labels which will, if supplied, over-ride the colnames of coodinates.\n#' @param title Title for the plot.\n#' @param legend.title Title for the legend (which only appears if group is not null).\n#' @param fixed.aspect if true, forces the x and y dimensions to be on the same scale.\n#' @param auto.tidy Move the labels around so that fewer overlap.\n#' @param colors Colors that are cycled through where there is only one series, or, used to demarkate series where there are multiple series.\n#' @param auto.color Automatically colors the points (if FALSE, the first color is used).\n#' @param general.color The color to be used in axes and titles.\n#' @param point.size Size of the dot representing the poing (i.e., the glyph).\n#' @param label.size Font size of the text labels on the plot.\n#' @param axis.title.size Font size of the axis titles.\n#' @param axis.label.size Font size of the axis labels.\n#' @param title.size Font size of the chart title.\n#' @param overlap.fudge Determines the amount of space required between labels. A value of 1 corresponds to a best guess of\n#' no overlap. The guess can be wrong, so the plot can be improved by modifying this value, which has a muliplier effect.\n#' @param space.substitute Spaces in labels of points on plots are substituted with whatever is supplied.\n#' By default, a return character is used(i.e., \\link{\"\\n\"}). To replace with a period, use \\link{\"\\\\.\"}.\n#' @param ... Additional arguments.\n#'# @param object An object to be plotted.\n#'# @param row.description A title for the rows.\n#'# @param column.description A title for the columns.\n#' @return p A \\code{\\link[ggplot2]{ggplot}} plot.\n#'\n# # MDS - square\n# data(breakfastDissimilarities)\n#     type = \"interval\", eps = 1e-12, itmax = 100000)\n# LabeledScatterPlot(mdsInterval, title = \"Interval-scale MDS of Breakfast Dissimilarities\")\n#\n# data(colaPerceptions)\n# LabeledScatterPlot(colaPerceptions[,c(7,8)], title = \"Scatterplot of perceptions data\",\n#                           auto.tidy = TRUE, auto.color = 5, fixed.aspect = TRUE)\n#' @export\nLabeledScatterPlot <- function(coords, ...) UseMethod(\"LabeledScatterPlot\")\n\n#' @describeIn LabeledScatterPlot  Default labeled scatterplot\n#' @export\nLabeledScatterPlot.default = function(coords,  group = NULL, row.labels = NULL, col.labels = NULL, title = \"\", legend.title = \"\",\n                                      fixed.aspect = TRUE, auto.tidy = TRUE,\n                                      colors = q.colors, auto.color = TRUE, general.color = \"gray28\",\n                                      point.size = 2, label.size = 10, legend.size = 10,\n                                      axis.title.size = 12, axis.label.size = 10, title.size = 12,\n                                      overlap.fudge = 1,\n                                      space.substitute = \"\\n\",\n                                      ...) {\n  # Replacing spaces with ~ to work around bugs in ggplot\n  dimnames(coords)[[1]] <- gsub(\" \", space.substitute, dimnames(coords)[[1]])\n  # identifying the labels\n  if (is.null(row.labels))\n  {\n    row.labels <- rownames(coords)\n    #row.labels <-  gsub(\" \", space.substitute, row.labels)\n  }\n  n <- length(row.labels)\n  if (is.null(col.labels)) {\n    col.labels <- colnames(coords)\n    if(is.null(col.labels)) {\n        col.labels <- c(\"Dimension 1\", \"Dimension 2\")\n    }\n  }\n  xlab <- \"col1\" #Due to bugs in ggplot, the true column names can only be added at the end.\n  ylab <- \"col2\"\n  dimnames(coords)[[2]] <- c(xlab, ylab)\n    # Setting the colors\n    #\n    has.groups <- !is.null(group)\n    if (!has.groups)\n    {\n        if (auto.color)\n        {\n            group <- array(1:length(colors), n)\n        }\n        else\n        {\n            group = rep(1, n)\n        }\n    }\n    group <- factor(group)\n  #\n  # Setting limits to the axes so that they can easily accomodate the text\n  #\n  point.coords <- as.data.frame(coords)\n  point.coords$labels <- row.labels\n  # initial plot to get the coordinates\n   p <- ggplot2::ggplot(point.coords, ggplot2::aes_string(x = \"col1\",\n                                                          y = \"col2\", label = \"labels\"))\n#   p <- ggplot2::ggplot(point.coords, ggplot2::aes_string(x = col.labels[1],\n#                                                          y = col.labels[2], label = \"labels\"))\n  # p <- p + ggplot2::labs(x = col.labels[1], y = \"big dog\", label = \"labels\")\n  font.size.hack <- label.size * 25.4 / 72.77 # Converting from points to mm, only for geom_text\n  p <- p + ggplot2::geom_point()\n  if (fixed.aspect)\n    p <- p + ggplot2::coord_fixed(ratio = 1)#, xlim = NULL, ylim = NULL, wise = NULL)\n  #\n  # moving points and labels to avoid overlap\n  #\n  new.coords <- ReducePointAndLabelOverlap(p, label.size, !auto.tidy, fixed.aspect = fixed.aspect, overlap.fudge = overlap.fudge)\n  label.dimensions <- new.coords$dimensions\n  label.coords <- new.coords$label.coords\n  point.coords$labels <- label.coords$labels <- row.labels\n  point.coords$group <- label.coords$group <- group\n  smallest.x <- min(point.coords[,1], label.coords[,1] - label.dimensions[,1] / 2)\n  biggest.x <- max(point.coords[,1], label.coords[,1] + label.dimensions[,1] / 2)\n  smallest.y <- min(point.coords[,2], label.coords[,2] - label.dimensions[,2] / 2)\n  biggest.y <- max(point.coords[,2], label.coords[,2] + label.dimensions[,2] / 2)\n\n#   # Replacing spaces with ~ to work around bugs in ggplot\n#   dimnames(label.coords)[[1]] <- gsub(\"\\\\.\", \" \", dimnames(label.coords)[[1]])\n  #\n  # creating the plot a second time\n  #\n  p <- ggplot2::ggplot(point.coords, ggplot2::aes_string(x = xlab, y = ylab))#, colour = \"labels\")) #+  scale_fill_manual(values=c(\"#F8766D\", \"#00BA38\"))\n  p <- p + ggplot2::theme_bw()\n  p <- p + ggplot2::geom_point(size = point.size, ggplot2::aes(colour = group))\n  p <- p + ggplot2::geom_text(data = label.coords,\n                              ggplot2::aes_string(x = \"col1\", y = \"col2\",\n          label = \"labels\", group = \"group\", colour = \"group\",\n          lineheight = 1.02),\n          size = font.size.hack, show_guide  = F )\n  p <- p + ggplot2::labs(title = title, x = col.labels[1], y = col.labels[2])#, label = \"labels\")\n#  p <- p + ggplot2::labs(title = title, x = col.labels[1], y = col.labels[2])#, label = \"labels\")\n  p <- p + ggplot2::xlim(smallest.x, biggest.x) + ggplot2::ylim(smallest.y, biggest.y)\n  p <- p + ggplot2::scale_colour_manual(values = colors, name = legend.title)\n  if (fixed.aspect)\n    p = p + ggplot2::coord_fixed(ratio = 1)#, xlim = NULL, ylim = NULL, wise = NULL)\n  if (has.groups) {\n    #p = p + scale_colour_manual(values = qColors, name = legend.title)\n    p = p + ggplot2::theme(legend.text = ggplot2::element_text(colour = general.color, size = legend.size))\n  } else {\n    p <- p + ggplot2::theme(legend.position = \"none\")\n  }\n  p <- p + ggplot2::theme(axis.text.x = ggplot2::element_text(colour = general.color, size = axis.label.size))\n  p <- p + ggplot2::theme(axis.text.y = ggplot2::element_text(colour = general.color, size = axis.label.size))\n  p <- p + ggplot2::theme(axis.title.x = ggplot2::element_text(colour = general.color, size = axis.title.size))\n  p <- p + ggplot2::theme(axis.title.y = ggplot2::element_text(colour = general.color, size = axis.title.size))\n  p <- p + ggplot2::theme(axis.title = ggplot2::element_text(size = axis.title.size, face = \"bold\"))\n  p <- p + ggplot2::theme(plot.title = ggplot2::element_text(size = title.size, face=\"bold\", vjust = 1.2))\n  #\n  # connecting points to text using lines\n  #\n  for (i in 1:n) {\n    x <- coords[i, 1]\n    y <- coords[i, 2]\n    x1 <- label.coords[i, 1]\n    y1 <- label.coords[i, 2]\n    w <- label.dimensions[i, 1]\n    h <- label.dimensions[i, 2]\n    cs <- BoxCoordinates(x1, y1, w, h)\n    abs.slope <- function(x1, y1, x2, y2) {\n      abs((y1 - y2) / (x1 - x2))\n    }\n    if (DistanceToBox(x, y, cs[1], cs[2], cs[3], cs[4], cs[5], cs[6], cs[7], cs[8]) > h) {\n      line.color = colors[group[i]]\n      if (abs.slope(x, y, x1, y1) < 0.5) {\n        if (x > x1) { # point to the righy of label\n          p <- p + ggplot2::geom_segment(ggplot2::aes_string(x = x, xend = cs[3], y = y, yend = cs[2] + h / 2), colour = line.color, size = .5)#, size = 3)\n        } else  { # point to the left of label\n          p <- p + ggplot2::geom_segment(ggplot2::aes_string(x = x, xend = cs[1], y = y, yend = cs[2] + h / 2), colour = line.color, size = .5)#, colour = transparent.colors[i], size = 3)\n        }\n      } else {\n        if (y > y1) { # point above the label\n          p <- p + ggplot2::geom_segment(ggplot2::aes_string(x = x, xend = cs[1] + w / 2, y = y, yend=cs[8]), colour = line.color, size = .5)##, colour = transparent.colors[i], size = 3)\n        } else  { # point below the label\n          p <- p + ggplot2::geom_segment(ggplot2::aes_string(x = x, xend = cs[1] + w / 2, y = y, yend=cs[2]), colour = line.color, size = .5)##, colour = transparent.colors[i], size = 3)\n        }\n      }\n    }\n  }\n  p\n}\n\n#\n# #'  @describeIn LabeledScatterPlot  Labeled scatterplot of smacof object\n# #'  @export\n# LabeledScatterPlot.smacof = function(object, ...)\n# {\n#     LabeledScatterPlot.default(object$conf, fixed.aspect = TRUE, ...)\n# }\n#\n# #'  @describeIn LabeledScatterPlot  Labeled scatterplot of smacofB object\n# #'  @export\n# LabeledScatterPlot.smacofB = function(object, ...)\n# {\n#     LabeledScatterPlot.default(object$conf, fixed.aspect = TRUE, ...)\n# }\n#\n#\n# #'  @describeIn LabeledScatterPlot  Labeled scatterplot of smacofR object\n# #'  @export\n# LabeledScatterPlot.smacofR = function(object, ...) # # row.description = \"Rows\", column.description = \"Columns\",  ...) {\n# {\n#     coords = rbind(object$conf.row, object$conf.col)\n#     group = c(rep(row.description, length(object$spp.row)),rep(column.description, length(object$spp.col)))\n#     LabeledScatterPlot.default(coords, fixed.aspect = TRUE, group = group, ...)\n# }\n\n\n",
    "created" : 1450300856372.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "328903266",
    "id" : "A255D028",
    "lastKnownWriteTime" : 1450422068,
    "path" : "~/GitHub/flipPlots/R/scatterplot.R",
    "project_path" : "R/scatterplot.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}