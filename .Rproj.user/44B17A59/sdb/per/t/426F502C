{
    "contents" : "#' Distance between points\n#' \\code{Distance} A Euclidean distance between points\n#'\n#' @param e1x The x coordinate of a point.\n#' @param e1y The y coordinate of a point.\n#' @param e2x The x coordinate of another point.\n#' @param e2y The y coordinate of another point.\n#' @return The distance.\nDistance = function(e1x, e1y, e2x, e2y) {\n  #\n  sqrt(SquaredDistance(e1x, e1y, e2x, e2y))\n}\n\n#' Squared distance between points\n#' \\code{SquaredDistance} Squared Euclidean distance between points\n#'\n#' @param e1x The x coordinate of a point.\n#' @param e1y The y coordinate of a point.\n#' @param e2x The x coordinate of another point.\n#' @param e2y The y coordinate of another point.\n#' @return The squared distance.\nSquaredDistance = function(e1x, e1y, e2x, e2y) {\n  (e2y - e1y)^2 + (e2x - e1x)^2\n}\n\n#' Distance to a line segment\n#' \\code{DistanceToLineSegment} Computes the distance between a point and the nearest point on a line segment\n#'\n#' @param px The x coordinate of a point.\n#' @param py The y coordinate of a point.\n#' @param ax The x coordinate of one end of a line.\n#' @param ay The y coordinate of one end of a line.\n#' @param bx The x coordinate of the other end of a line.\n#' @param by The y coordinate of the other end of a line.\n#' @return The distance.\nDistanceToLineSegment = function(px, py, ax, ay, bx, by) {\n  l2 = SquaredDistance(ax, ay, bx, by)\n  if (l2 == 0)\n    return(sqrt(SquaredDistance(px, py, ax, ay)))\n  t = ((px - ax) * (bx - ax) + (py - ay) * (by - ay)) / l2\n  if (t < 0)\n    return(sqrt(SquaredDistance(px, py, ax, ay)))\n  if (t > 1)\n    return(sqrt(SquaredDistance(px, py, bx, by)))\n  sqrt(SquaredDistance(px, py, ax + t * (bx - ax), ay + t * (by - ay)))\n}\n\n#' Distance to a line segment\n#' \\code{DistanceToBox} Computes the distance between a point and the nearest point on a box (0 if in the box)\n#'\n#' @param px The x coordinate of a point.\n#' @param py The y coordinate of a point.\n#' @param ax The x coordinate of the bottom-left of the box.\n#' @param ay The y coordinate of the bottom-left of the box.\n#' @param bx The x coordinate of the bottom-right of the box.\n#' @param by The y coordinate of the bottom-right of the box.\n#' @param cx The x coordinate of the top-right of the box.\n#' @param cy The y coordinate of the top-right of the box.\n#' @param dx The xcoordinates of the top-left of the box.\n#' @param dy The y coordinate of the top-left of the box.\n#' @return The squared distance.\nDistanceToBox = function(px, py, ax, ay, bx, by, cx, cy, dx, dy) {\n  d.horizontal = Distance(ax, ay, bx, by)\n  d.vertical = Distance(bx, by, cx, cy)\n  d.p.ab = DistanceToLineSegment(px, py, ax, ay, bx, by)\n  d.p.bc = DistanceToLineSegment(px, py, bx, by, cx, cy)\n  d.p.cd = DistanceToLineSegment(px, py, cx, cy, dx, dy)\n  d.p.da = DistanceToLineSegment(px, py, dx, dy, ax, ay)\n  # checking to see if point is in the box\n  if (d.p.bc <= d.horizontal & d.p.da <= d.horizontal & d.p.ab <= d.vertical & d.p.cd <= d.vertical)\n    return(0)\n  min(d.p.ab, d.p.bc, d.p.cd, d.p.da)\n}\n\n#' Whether or not two boxes overlap\n#' \\code{BoxOverlap} Checks to see if two boxes overlap\n#'\n#' @param ax1 The x coordinate of the bottom-left of the first box.\n#' @param ay1 The y coordinate of the bottom-left of the first box.\n#' @param bx1 The x coordinate of the bottom-right of the first box.\n#' @param by1 The y coordinate of the bottom-right of the first box.\n#' @param cx1 The x coordinate of the top-right of the first box.\n#' @param cy1 The y coordinate of the top-right of the first box.\n#' @param dx1 The x coordinate of the top-left of the first box.\n#' @param dy1 The y coordinate of the top-left of the first box.\n#' @param ax2 The x coordinate of the bottom-left of the second box.\n#' @param ay2 The y coordinate of the bottom-left of the second box.\n#' @param bx2 The x coordinate of the bottom-right of the second box.\n#' @param by2 The y coordinate of the bottom-right of the second box.\n#' @param cx2 The x coordinate of the top-right of the second box.\n#' @param cy2 The y coordinate of the top-right of the second box.\n#' @param dx2 The x coordinate of the top-left of the second box.\n#' @param dy2 The y coordinate of the top-left of the second box.\n#' @return true if the boxes overlap and false otherwise.\nBoxOverlap = function(ax1, ay1, bx1, by1, cx1, cy1, dx1, dy1, ax2, ay2, bx2, by2, cx2, cy2, dx2, dy2) {\n  # Returns: boolean\n  #\n  if (DistanceToBox(ax1, ay1, ax2, ay2, bx2, by2, cx2, cy2, dx2, dy2) == 0)\n    return(TRUE)\n  if (DistanceToBox(bx1, by1, ax2, ay2, bx2, by2, cx2, cy2, dx2, dy2) == 0)\n    return(TRUE)\n  if (DistanceToBox(cx1, cy1, ax2, ay2, bx2, by2, cx2, cy2, dx2, dy2) == 0)\n    return(TRUE)\n  if (DistanceToBox(dx1, dy1, ax2, ay2, bx2, by2, cx2, cy2, dx2, dy2) == 0)\n    return(TRUE)\n  if (DistanceToBox(ax2, ay2, ax1, ay1, bx1, by1, cx1, cy1, dx1, dy1) == 0)\n    return(TRUE)\n  if (DistanceToBox(bx2, by2, ax1, ay1, bx1, by1, cx1, cy1, dx1, dy1) == 0)\n    return(TRUE)\n  if (DistanceToBox(cx2, cy2, ax1, ay1, bx1, by1, cx1, cy1, dx1, dy1) == 0)\n    return(TRUE)\n  if (DistanceToBox(dx2, dy2, ax1, ay1, bx1, by1, cx1, cy1, dx1, dy1) == 0)\n    return(TRUE)\n  FALSE\n}\n\n\n#' Box coordinates\n#' \\code{BoxOverlap} Computes the positions of the corner of a box.\n#'\n#' @param x x coordinate of the middle of the box.\n#' @param y y coordinate of the middle of the box.\n#' @param w width of the box in the x-scale.\n#' @param h height  of the box in the y-scale.\n#' @return A vector containing the coordinates of a box.\nBoxCoordinates = function(x, y, w, h) {\n  p1 = x - w / 2\n  p2 = y - h / 2\n  p3 = x + w / 2\n  p4 = y + h / 2\n  c(p1, p2, p3, p2, p3, p4, p1, p4)\n}\n\n#' Box center\n#' \\code{BoxCenter} Computes the coordinates of the center of a box based upon the coordinates of the corner.\n#'\n#' @param ax The x coordinate of the bottom-left of the box.\n#' @param ay The y coordinate of the bottom-left of the box.\n#' @param bx The x coordinate of the bottom-right of the box.\n#' @param by The y coordinate of the bottom-right of the box.\n#' @param cx The x coordinate of the top-right of the box.\n#' @param cy The y coordinate of the top-right of the box.\n#' @param dx The x coordinate of the top-left of the box.\n#' @param dy The y coordinate of the top-left of the box.\n#' @return vector containing the x,y coordinates of the center.\nBoxCenter = function(ax, ay, bx, by, cx, cy, dx, dy) {\n  c((ax + bx) / 2, (ay + dy) / 2)\n}\n\n#' Box Overlaps\n#' \\code{IsOverlap} Tests if a box overlaps any other boxes.\n#'\n#' @param boxes A list of boxes, where each box is its coordinates.\n#' @param this.box The box to check to see if it overlaps with the rest.\n#' @return TRUE if there is an overlap and false otherwise.\nIsOverlap = function(boxes, this.box) {\n  if (length(boxes) == 0)\n    return(FALSE)\n  for (box in boxes) {\n    if (BoxOverlap(box[1],box[2],box[3],box[4],box[5],box[6],box[7],box[8], this.box[1],this.box[2],this.box[3],this.box[4],this.box[5],this.box[6],this.box[7],this.box[8]))\n      return(TRUE)\n  }\n  FALSE\n}\n\n#' ggplot xlim\n#' \\code{GetXlim} Tests if a box overlaps any other boxes.\n#'\n#' @param p A \\code{\\link[ggplot2]{ggplot}} plot.\n#' @return A vector containing the minimum and and maximum value of x plotted.\nGetXlim = function(p) {\n  g = ggplot_build(p)\n  g$panel$ranges[[1]]$x.range\n}\n\n#' ggplot ylim\n#' \\code{GetYlim} Tests if a box overlaps any other boxes.\n#'\n#' @param p A \\code{\\link[ggplot2]{ggplot}} plot.\n#' @return A vector containing the minimum and and maximum value of y  plotted.\nGetYlim = function(p) {\n  g = ggplot_build(p)\n  g$panel$ranges[[1]]$y.range\n}\n\n#' Find better cootrdinates for text labels\n#' \\code{GetYlim} Identifies a better set of coordinates to place labels in a labeled ggplot scatterplot.\n#'\n#' @param p A \\code{\\link[ggplot2]{ggplot}} plot.\n#' @param cex Relative font, line and glyph size.\n#' @param fixed.aspect If true, forces the x and y dimensions to be on the same scale.\n#' @param tstep The angle (theta) step size as the algorithm spirals out.\n#' @param rstep The radius step size (in standard deviations) as the algorithm spirals out.\n#' @return label.coords Recommended label coordinates.\n#' @return dimensions Width and height of the text to be plotted in terms of the scale of x and y.\nReducePointAndLabelOverlap = function (p, cex = 1, fixed.aspect = FALSE, tstep = 0.1, rstep = 0.1){\n  # Inspired by  wordlayout {wordcloud}\n  #\n  # getting the coordinates\n  labels = p$data$labels\n  label.coords = point.coords = p$data[,1:2]\n  col.labels = colnames(label.coords)\n  n = length(labels)\n  # determining scale of the points and text relative to plot coordinates (dodgy hack)\n  #print( par()$pin)\n  initial.x.scale = x.scale = diff(GetXlim(p)) / par()$pin[1] * 0.8\n  y.scale = diff(GetYlim(p)) / par()$pin[2] * 0.8\n  #print(c(\"orig\", x.scale, y.scale))\n  if (fixed.aspect) {\n    x.scale = y.scale = max(x.scale, y.scale)\n  }\n  # print(c(\"modified\", x.scale, y.scale))\n  w = h = strheight(\"Jj\", \"inches\", cex = cex)\n  initial.w = w = w * x.scale\n  h = h * y.scale\n  #print(c(w, h))\n  #print(strwidth(labels, \"inches\", cex = cex))\n  widths = strwidth(labels, \"inches\", cex = cex) * x.scale# / initial.x.scale\n  sdx = sd(label.coords[,1], na.rm = TRUE)\n  sdy = sd(label.coords[,2], na.rm = TRUE)\n  if (sdx == 0)\n    sdx <- 1\n  if (sdy == 0)\n    sdy <- 1\n  # computing position of the points (assuming they are the same height as the first label)\n  boxes = vector(\"list\", n)\n  for (i in 1:n)\n    boxes[[i]] = BoxCoordinates(point.coords[i,1], point.coords[i,2], w * .8, h * .8)\n  # preventing overlap of points\n  for (i in 2:n)\n    for (prev.i in 1:(i - 1))\n      if (sum(point.coords[i,] == point.coords[prev.i,]) == 2) {\n        radian = 2 * pi * (n + i) / (2 * n)\n        point.coords[i, 1] = point.coords[i, 1] + w / 4 * cos(radian)\n        point.coords[i, 2] = point.coords[i, 2] + h / 4 * sin(radian)\n      }\n  # getting the coordinates for the labels\n  dimensions = matrix(c(widths,rep(h,n)), n, 2, dimnames = list(labels, c(\"width\", \"height\")))\n  label.coords[,2] = h + label.coords[,2] #putting the initial labels above the points\n  box.coordinates = vector(\"list\", n)\n  thetas = 2 * pi * (1:n) / n\n  for (i in 1:n) {\n    theta = thetas[i]\n    x1 = x0 = label.coords[i, 1]\n    y1 = y0 = label.coords[i, 2]\n    r = 0\n    label = labels[i]\n    w = widths[i]\n    overlapped = TRUE\n    new.position.counter = 0\n    while (overlapped) {\n      this.box = BoxCoordinates(x1, y1, w, h)\n      if (!IsOverlap(boxes, this.box)) {\n        boxes[[i + n]] <- this.box\n        label.coords[i, ] =  c(x1, y1)\n        overlapped = FALSE\n      } else {\n        new.position.counter = new.position.counter + 1\n        if (new.position.counter == 1){# trying to put the point underneath\n          y1 = y0 - 2 * h\n        } else if (new.position.counter == 2){# trying to put the point to the left\n          x1 = x0 - (initial.w + widths[i])\n          y1 = y0 - h * 1.2\n        } else if (new.position.counter == 3){# trying to put the point to the left\n          x1 = x0 + (initial.w + widths[i])\n          y1 = y0 - h\n        } else {\n          theta <- theta + tstep\n          r <- r + rstep * tstep/(2 * pi)\n          x1 <- x0 + sdx * r * cos(theta)\n          y1 <- y0 + sdy * r * sin(theta)\n        }\n      }\n    }\n  }\n  list(label.coords = as.data.frame(label.coords), dimensions = dimensions)\n}\n\n\n#' Find better cootrdinates for text labels\n#' \\code{GetYlim} Identifies a better set of coordinates to place labels in a labeled ggplot scatterplot.\n#'  #\n#' @param coords The xy coordinates of the points.\n#' @param group A factor indicating group membership for each point.\n#' @param row.labels A vector of labels which will, if supplied, over-ride the rownames of coodinates.\n#' @param col.labels A vector of labels which will, if supplied, over-ride the colnames of coodinates.\n#' @param title Title for the plot.\n#' @param legend.title Title for the legend (which only appears if group is not null).\n#' @param fixed.aspect if true, forces the x and y dimensions to be on the same scale.\n#' @param auto.tidy Move the labels around so that fewer overlap.\n#' @param colors Colors that are cycled through where there is only one series, or, used to demarkate series where there are multiple series.\n#' @param auto.color When the number of rows of coords is less than or equal to this, a single color is used to label the points.  Otherwise, they cycle throuogh the colors.\n#' @param coords Relative font, line and glyph size.\n#' @param general.color The color to be used in axes and titles.\n#' @param cex Relative font, line and glyph size.\n#' @param ... Additional arguments.\n#' @param object An object to be plotted.\n#' @param row.description A title for the rows.\n#' @param column.description A title for the columns.\n#' @return p A \\code{\\link[ggplot2]{ggplot}} plot.\n#' @examples\n#'\n#' # MDS - square\n#' library(smacof)\n#' data(breakfastDissimilarities)\n#' mdsInterval <- smacofSym(breakfastDissimilarities[[4]],\n#'     type = \"interval\", eps = 1e-12, itmax = 100000)\n#' LabeledScatterPlot(mdsInterval, title = \"Interval-scale MDS of Breakfast Dissimilarities\")\n#'\n#' data(colaPerceptions)\n#' LabeledScatterPlot(colaPerceptions[,c(7,8)], title = \"Scatterplot of perceptions data\",\n#'                           auto.tidy = TRUE, auto.color = 5, fixed.aspect = TRUE)\n#' @export\nLabeledScatterPlot <- function(coords, ...) UseMethod(\"LabeledScatterPlot\")\n\n#' @describeIn LabeledScatterPlot  Default labeled scatterplot\n#' @export\nLabeledScatterPlot.default = function(coords, group = NULL, row.labels = NULL, col.labels = NULL, title = \"\", legend.title = \"\",\n                                      fixed.aspect = TRUE, auto.tidy = TRUE,\n                                      colors = qColors, auto.color = 10, general.color = \"gray28\",\n                                      cex = 1, ...) {\n  require(\"ggplot2\")\n  # identifying the labels\n  if (is.null(row.labels))\n    row.labels = rownames(coords)\n  n = length(row.labels)\n  if (is.null(col.labels)) {\n    col.labels = colnames(coords)\n    if(is.null(col.labels)) {\n      xlab = \"Dimension 1\"\n      ylab = \"Dimension 2\"\n    } else {\n      xlab = col.labels[1]\n      ylab = col.labels[2]\n    }\n  }\n  # Setting the colors\n  #\n  has.groups = !is.null(group)\n  if (!has.groups) {\n    if (auto.color >= n) {\n      group = rep(5, n)\n    } else {\n      group = array(1:length(colors), n)\n    }\n  }\n  group = factor(group)\n  #\n  # Setting limits to the axes so that they can easily accomodate the text\n  #\n  point.coords = as.data.frame(coords)\n  point.coords$labels =  row.labels\n  # initial plot to get the coordinates\n  p = ggplot(point.coords, aes_string(x = col.labels[1], y = col.labels[2], label = \"labels\")) + geom_point()\n  if (fixed.aspect)\n    p = p + coord_fixed(ratio = 1)#, xlim = NULL, ylim = NULL, wise = NULL)\n  #\n  # moving points and labels to avoid overlap\n  #\n  new.coords = ReducePointAndLabelOverlap(p, cex, fixed.aspect)\n  label.dimensions = new.coords$dimensions\n  label.coords = new.coords$label.coords\n  point.coords$labels = label.coords$labels = row.labels\n  point.coords$group = label.coords$group = group\n  smallest.x = min(point.coords[,1], label.coords[,1] - label.dimensions[,1] / 2)\n  biggest.x = max(point.coords[,1], label.coords[,1] + label.dimensions[,1] / 2)\n  smallest.y = min(point.coords[,2], label.coords[,2] - label.dimensions[,2] / 2)\n  biggest.y = max(point.coords[,2], label.coords[,2] + label.dimensions[,2] / 2)\n  #\n  # creating the plot a second time\n  #\n  p = ggplot(point.coords, aes_string(x = col.labels[1], y = col.labels[2]))#, colour = \"labels\")) #+  scale_fill_manual(values=c(\"#F8766D\", \"#00BA38\"))\n  p = p + theme_bw()\n  p = p + geom_point(size = 2 * cex, aes(colour = group))\n  p = p + geom_text(data = label.coords, aes_string(x = col.labels[1], y = col.labels[2], label = \"labels\", group = \"group\", colour = \"group\"), size = 3 * cex, show_guide  = F )\n  p = p + labs(title = title)\n  p = p + xlim(smallest.x, biggest.x) + ylim(smallest.y, biggest.y)\n  p = p + scale_colour_manual(values = qColors, name = legend.title)\n  if (fixed.aspect)\n    p = p + coord_fixed(ratio = 1)#, xlim = NULL, ylim = NULL, wise = NULL)\n  if (has.groups) {\n    #p = p + scale_colour_manual(values = qColors, name = legend.title)\n    p = p + theme(legend.text = element_text(colour = general.color, size = 10 * cex))\n  } else {\n    p = p + theme(legend.position = \"none\")\n  }\n  p = p + theme(axis.text.x = element_text(colour = general.color, size = 8 * cex))\n  p = p + theme(axis.text.y = element_text(colour = general.color, size = 8 * cex))\n  p = p + theme(axis.title.x = element_text(colour = general.color, size = 10 * cex))\n  p = p + theme(axis.title.y = element_text(colour = general.color, size = 10 * cex))\n  p = p + theme(axis.title = element_text(size = 10, face = \"bold\"))\n  p = p + theme(plot.title = element_text(size = 12 * cex, face=\"bold\", vjust = cex * 1.2))\n  #\n  # connecting points to text using lines\n  #\n  for (i in 1:n) {\n    x = coords[i, 1]\n    y = coords[i, 2]\n    x1 = label.coords[i, 1]\n    y1 = label.coords[i, 2]\n    w = label.dimensions[i, 1]\n    h = label.dimensions[i, 2]\n    cs = BoxCoordinates(x1, y1, w, h)\n    abs.slope = function(x1, y1, x2, y2) {\n      abs((y1 - y2) / (x1 - x2))\n    }\n    if (DistanceToBox(x, y, cs[1], cs[2], cs[3], cs[4], cs[5], cs[6], cs[7], cs[8]) > h) {\n      line.color = colors[group[i]]\n      if (abs.slope(x, y, x1, y1) < 0.5) {\n        if (x > x1) { # point to the righy of label\n          p = p + geom_segment(aes_string(x = x, xend = cs[3], y = y, yend = cs[2] + h / 2), colour = line.color, size = cex / 2)#, size = 3)\n        } else  { # point to the left of label\n          p = p + geom_segment(aes_string(x = x, xend = cs[1], y = y, yend = cs[2] + h / 2), colour = line.color, size = cex / 2)#, colour = transparent.colors[i], size = 3)\n        }\n      } else {\n        if (y > y1) { # point above the label\n          p = p + geom_segment(aes_string(x = x, xend = cs[1] + w / 2, y = y, yend=cs[8]), colour = line.color, size = cex / 2)##, colour = transparent.colors[i], size = 3)\n        } else  { # point below the label\n          p = p + geom_segment(aes_string(x = x, xend = cs[1] + w / 2, y = y, yend=cs[2]), colour = line.color, size = cex / 2)##, colour = transparent.colors[i], size = 3)\n        }\n      }\n    }\n  }\n  p\n}\n\n\n#' @describeIn LabeledScatterPlot  Labeled scatterplot of smacof object\n#' @export\nLabeledScatterPlot.smacof = function(object, ...) {\n  LabeledScatterPlot.default(object$conf, fixed.aspect = TRUE, ...)\n}\n\n#' @describeIn LabeledScatterPlot  Labeled scatterplot of smacofB object\n#' @export\nLabeledScatterPlot.smacofB = function(object, ...) {\n  LabeledScatterPlot.default(object$conf, fixed.aspect = TRUE, ...)\n}\n\n\n#' @describeIn LabeledScatterPlot  Labeled scatterplot of smacofR object\n#' @export\nLabeledScatterPlot.smacofR = function(object, row.description = \"Rows\", column.description = \"Columns\",  ...) {\n  coords = rbind(object$conf.row, object$conf.col)\n  print(coords)\n  group = c(rep(row.description, length(object$spp.row)),rep(column.description, length(object$spp.col)))\n  print(group)\n  LabeledScatterPlot.default(coords, fixed.aspect = TRUE, group = group, ...)\n}\n",
    "created" : 1447996935184.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2886404038",
    "id" : "426F502C",
    "lastKnownWriteTime" : 1447996585,
    "path" : "~/GitHub/flipPlots/R/scatterplot.R",
    "project_path" : "R/scatterplot.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}