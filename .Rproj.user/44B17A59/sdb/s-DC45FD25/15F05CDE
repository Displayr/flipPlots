{
    "contents" : "#' \\code{GeographicRegionRowNames} Names of geographic regions.\n#' Returns the list of unique geographic names that\n#' can be used when creating a WorldMap.\n#' @param type... The name of the geographic region type. See \\code{\\link{GeographicRegionTypes}}\n#' @examples\n#' GeographicRegionRowNames(\"name\")\n#' GeographicRegionRowNames(\"continent\")\n#'\n#' @export\nGeographicRegionRowNames <- function(type)\n{\n    data(\"country.coordinates\", envir=environment())\n    unique(country.coordinates[[type]])\n}\n\n#' \\code{GeographicRegionTypes} Types of Geographic Regions\n#' The geographic region types that are available for refering\n#' in a map. E.g., \\code{name}, \\code{continent},\n#' @examples\n#' GeographicRegionTypes()\n#' @export\nGeographicRegionTypes <- function()\n{\n    data(\"country.coordinates\", envir=environment())\n    names(country.coordinates)\n}\n# # Reading the coordinates.\n# getCoordinates <- function()\n# {\n#     return(rgdal::readOGR(\"https://raw.github.com/datasets/geo-boundaries-world-110m/master/countries.geojson\", \"OGRGeoJSON\"))\n# }\n\n#' \\code{WorldMap} World Map\n#'\n#' Creates a map with a table as an input, using shading to represent the values of\n#' countries on the map.\n#' @param table An matrix, two-dimensional array, table or vector, containing the data\n#' to be plotted. The \\code{\\link{rownames}} (or  \\code{\\link{rownames}} in the case\n#' of a vector) should contain the names of the geographic entities to be plotted (see\n#' \\code{type}).\n#' @param type The type of geographic information to be plotted. By default, this is\n#' \\code{name}, which refers to the name of the country. To see a list of the available\n#' types, use \\code{GeographicRegionTypes()}. To see a complete list of names within a type,\n#' use \\code{GeographicRegionRowNames(\"type\")}.\n#' @param treat.NA.as.0 Plots any \\code{NA} values in the data and any geographical entities\n#' without data with as having a 0 value.\n#' @param only.show.regions.in.table When TRUE, only geographic entities that are included in\n#' the table are shown on the table.\n#' @param add.detail Display names of geographical entities on the map. When TRUE, it also changes\n#' the appearance of the map, making the map wrap around. The only way to prevent this is to\n#' resize the map.\n#' @param remove.last.column Deletes the last column of the table priori to creating the map\n#' , unless the table is a vector or only has one column.\n#' @param colors A vector of two colors, which are used as endpoints in interpolating colors.\n#' @param color.NA The color used to represent missing values. Not used when \\link{treat.NA.as.0},\n#' is set to missing.\n#' @param legend.title The text to appear above the legend.\n#' @param remove.antarctica Automatically removes Antarctica from the ma. Defaults to TRUE.\n#' @param remove.seven.seas Automatically removes the seven seas from the map. Defaults to TRUE.\n#' @param ... Additional arguments affecting the goodness-of-fit displayed.\n#' @details\n#' This function is based on the \\code{\\link{leaflet}} package. See\n#' \\url{https://rstudio.github.io/leaflet/} for an overview of this package and\n#' how to use it without using \\code{\\link{WorldMap}}.\n# valid.continent.names <- matrix(1:4, 4, 2, dimnames = list(c(\"Asia\", \"Africa\", \"Europe\", \"South America\"), LETTERS[1:2]))\n#' @examples\n#' WorldMap(valid.continent.names, type = \"continent\")\n#' WorldMap(valid.continent.names, type = \"continent\", treat.NA.as.0 = TRUE)\n#' WorldMap(valid.continent.names, type = \"continent\", treat.NA.as.0 = TRUE, remove.last.column = TRUE)\n#' WorldMap(valid.continent.names[,1], type = \"continent\", treat.NA.as.0 = TRUE)\n#' WorldMap(valid.continent.names, type = \"continent\", remove.last.column = TRUE)\n#' WorldMap(valid.continent.names, type = \"continent\", remove.last.row = TRUE)\n#' WorldMap(valid.continent.names, type = \"continent\", colors = c(\"#AAAAAA\", \"#FFFFFF\"))\n#' WorldMap(valid.continent.names, type = \"continent\",\n#'          colors = c(\"#AAAAAA\", \"#FFFFFF\"), treat.NA.as.0 = TRUE, color.NA = \"#23B0DB\")\n#' WorldMap(valid.continent.names, type = \"continent\",\n#'          colors = c(\"#AAAAAA\", \"#FFFFFF\"), treat.NA.as.0 = FALSE, color.NA = \"#23B0DB\")\n#' WorldMap(valid.continent.names, type = \"continent\",\n#'          colors = c(\"#AAAAAA\", \"#FFFFFF\"), treat.NA.as.0 = FALSE, color.NA = \"#23B0DB\",\n#'          legend.title = \"% agree\")\n#' WorldMap(valid.continent.names, type = \"continent\",\n#'          colors = c(\"#AAAAAA\", \"#FFFFFF\"), treat.NA.as.0 = FALSE, color.NA = \"#23B0DB\",\n#'          legend.title = \"% agree\", only.show.regions.in.table = TRUE)\n#' WorldMap(valid.continent.names, type = \"continent\",\n#'          treat.NA.as.0 = TRUE,\n#'          legend.title = \"% agree\", only.show.regions.in.table = TRUE)\n#' valid.continent.names[1] <- NA\n#' WorldMap(valid.continent.names, type = \"continent\",\n#'          legend.title = \"% agree\", only.show.regions.in.table = TRUE)\n#' WorldMap(valid.continent.names, type = \"continent\", remove.antarctica = FALSE)\n#' WorldMap(valid.continent.names, type = \"continent\", remove.antarctica = FALSE)\n#' WorldMap(valid.continent.names, type = \"continent\", add.detail = TRUE, remove.antarctica = FALSE)\n#' @export\nWorldMap = function(table,\n                    type = \"name\",\n                    treat.NA.as.0 = FALSE,\n                    only.show.regions.in.table = FALSE,\n                    add.detail = FALSE,\n                    remove.last.column = FALSE,\n                    remove.last.row = FALSE,\n                    colors = c(\"#CCF3FF\",\"#23B0DB\"),\n                    color.NA = \"#808080\",\n                    legend.title = \"\",\n                    remove.antarctica = TRUE){\n     # Correcting rowname errors for country names.\n    if (type == \"name\")\n    {\n        correct.names <- c(\"United States\", \"United Kingdom\")\n        incorrect.names <- c(\"United States of America\", \"United Kingdom of Great Britain and Northern Ireland\")\n        rows.to.change <- match(incorrect.names, rownames(table))\n        if(!is.na(rows.to.change[1]))\n            rownames(table)[rows.to.change] <- correct.names\n    }\n    # Neatening the data.\n    table.name <- deparse(substitute(table))\n    if(is.vector(table) || length(dim(table)) == 1)\n    {\n        if(is.null(names(table)))\n            stop(paste(table.name, \"has no names.\"))\n        table <- as.matrix(table)\n        dimnames(table)[[2]] = table.name\n    }\n    else\n    {\n        if(length(dim(table)) != 2)\n            stop(paste(\"Tables must contain one or more columns of data, and may not have three or more dimensions.\"))\n        if(is.null(colnames(table)))\n            stop(paste(table.name, \"has no column names\"))\n        if(is.null(rownames(table)))\n            stop(paste(table.name, \"has no row names. The row names are required to match known geographic entitites.\"))\n        if (remove.last.column & ncol(table) > 1)\n            table <- table[, -ncol(table), drop = FALSE]\n    }\n    if (remove.last.row)\n        table <- table[-nrow(table), , drop = FALSE]\n    table.names <- rownames(table)\n    if (treat.NA.as.0)\n        table[is.na(table)] <- 0\n    # Getting geographic boundaries\n    data(\"country.coordinates\", envir=environment())\n    coords <- country.coordinates\n    coords[[type]] <- as.character(coords[[type]])\n    if (remove.antarctica)\n         coords <- coords[!coords$continent %in% \"Antarctica\",]\n    coords.names <- coords[[type]]\n    if (only.show.regions.in.table)\n        coords <- coords[coords.names %in% table.names,]\n    coords.names <- coords[[type]]\n    # Checking to see if input data is OK.\n    incorrect.names <- !table.names %in% coords.names\n    if (sum(incorrect.names) != 0)\n        stop(paste(\"Incorrect rowname:\", paste(table.names[incorrect.names],collapse=\",\")))\n    # Splicing data onto coordinate data.frame.\n    country.lookup <- match(coords.names,table.names)\n    categories <- colnames(table)\n    n.categories <- length(categories)\n    for (i in 1:n.categories)\n    {\n        new.var <- table[country.lookup, i]\n        if(treat.NA.as.0)\n            new.var[is.na(new.var)] <- 0\n        coords$table <- new.var\n        names(coords)[ncol(coords)] <- paste(\"table\", i, sep = \"\")\n    }\n    # Creating a variable for use in scaling the legend.\n    min.value <- min(table, na.rm = TRUE)\n    if (treat.NA.as.0 & nrow(table) < nrow(country.coordinates))\n        min.value <- min(0, min.value)\n    coords$table.max <- apply(table, 1, max)[country.lookup]\n    if(treat.NA.as.0)\n        coords$table.max[is.na(coords$table.max)] <- 0\n    min.in.table.max <- min(coords$table.max , na.rm = TRUE)\n    if (min.value < min.in.table.max) #Replacing the minimum with the global minimum.\n        coords$table.max[match(min.in.table.max, coords$table.max)] <- min.value\n    # Creating the map\n    map = leaflet(coords)\n    opacity = 1\n    if (add.detail) {\n        opacity = .2\n        map = addTiles(map)\n    }\n    .pal <- colorNumeric(palette = colors,domain = range(coords$table.max, na.rm = TRUE),\n            na.color = color.NA)\n    map <- addLegend(map, \"bottomright\", pal = .pal, values = ~table.max,\n                    title = legend.title,\n                    labFormat = labelFormat(prefix = \"\"),\n                    opacity = opacity,\n                    na.label = ifelse(treat.NA.as.0, \"0\", \"NA\"))\n    if (n.categories == 1) {\n        map = addPolygons(map, stroke = FALSE, smoothFactor = 0.2,\n                          fillOpacity = opacity, color = ~.pal(table1))\n    } else {\n        for (i in 1:n.categories) {\n            cl = as.formula(paste(\"~.pal(table\", i, \")\", sep = \"\"))\n            map = addPolygons(map, stroke = FALSE, smoothFactor = 0.2,\n                               fillOpacity = opacity,\n                              color = cl, group = categories[i])\n        }\n        map = addLayersControl(map, baseGroups = categories,\n            options = layersControlOptions(collapsed = FALSE))\n    }\nmap}\n\n",
    "created" : 1448330782271.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2308015573",
    "id" : "15F05CDE",
    "lastKnownWriteTime" : 1448492633,
    "path" : "~/GitHub/flipPlots/R/worldmap.R",
    "project_path" : "R/worldmap.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}